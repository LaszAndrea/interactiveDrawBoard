<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Drawing Board</title>
    <style>
        body { text-align: center; }
        canvas { border: 1px solid black; cursor: crosshair; }
        .toolbar { margin: 10px; display: flex; justify-content: center; gap: 10px; }
        .tool-option, .color-option { width: 30px; height: 30px; display: inline-block; cursor: pointer; border: 1px solid black; text-align: center; line-height: 30px; }
    </style>
</head>
<body>
    <h1>Interactive Drawing Board</h1>
    <div class="toolbar">
        <div class="color-option" style="background-color: black;" data-color="black"></div>
        <div class="color-option" style="background-color: red;" data-color="red"></div>
        <div class="color-option" style="background-color: blue;" data-color="blue"></div>
        <div class="color-option" style="background-color: green;" data-color="green"></div>
        <div class="tool-option" id="eraser">E</div>
        <div class="tool-option" id="clear">X</div>
        <div class="tool-option" id="fill">F</div>
        <div class="tool-option" id="brush">B</div>
        <div class="tool-option" id="undo">‚ü≤</div>
    </div>
    <canvas id="drawingBoard" width="800" height="500"></canvas>
    <script>
        const canvas = document.getElementById("drawingBoard");
const ctx = canvas.getContext("2d");
const socket = new WebSocket("ws://localhost:8080");

let drawing = false;
let color = "black";
let lastX = null, lastY = null;
let tool = "brush";
let history = [];
let currentStroke = [];

document.querySelectorAll(".color-option").forEach(option => {
    option.addEventListener("click", (event) => {
        color = event.target.getAttribute("data-color");
        tool = "brush";
    });
});

document.getElementById("eraser").addEventListener("click", () => {
    color = "white"; // Eraser uses white color
    tool = "eraser";
});

document.getElementById("clear").addEventListener("click", () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    socket.send(JSON.stringify({ type: 'clear' }));
    history = [];
});

document.getElementById("undo").addEventListener("click", () => {
    if (history.length > 0) {
        socket.send(JSON.stringify({ type: 'undo' }));
        history.pop();
        redrawCanvas();
    }
});

canvas.addEventListener("mousedown", (event) => {
    drawing = true;
    lastX = event.offsetX;
    lastY = event.offsetY;
    currentStroke = [];
});

canvas.addEventListener("mouseup", () => {
    drawing = false;
    if (currentStroke.length > 0) {
        history.push(currentStroke);
        socket.send(JSON.stringify({ type: 'draw', data: currentStroke }));
    }
});

canvas.addEventListener("mousemove", draw);

function draw(event) {
    if (!drawing || tool === "fill") return;
    const x = event.offsetX;
    const y = event.offsetY;
    
    ctx.strokeStyle = color;
    ctx.lineWidth = tool === "eraser" ? 10 : 2;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(x, y);
    ctx.stroke();
    
    currentStroke.push({ lastX, lastY, x, y, color });
    lastX = x;
    lastY = y;
}

function redrawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    history.forEach(stroke => {
        stroke.forEach(({ lastX, lastY, x, y, color }) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
        });
    });
}

socket.onmessage = (event) => {
    const { type, data } = JSON.parse(event.data);
    if (type === 'history') {
        data.forEach(stroke => {
            history.push(stroke);
            stroke.forEach(({ lastX, lastY, x, y, color }) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.lineCap = "round";
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
            });
        });
    } else if (type === 'draw') {
        history.push(data);
        data.forEach(({ lastX, lastY, x, y, color }) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
        });
    } else if (type === 'clear') {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        history = [];
    } else if (type === 'undo') {
        history.pop();
        redrawCanvas();
    } else if (type === 'erase') {
        // Handle the erase action (erase a part of the drawing)
        const { lastX, lastY, x, y, color } = data;
        ctx.strokeStyle = color;
        ctx.lineWidth = 10;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();
    }
};

    </script>
</body>
</html>